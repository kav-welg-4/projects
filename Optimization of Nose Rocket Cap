
import math
from tkinter.tix import Balloon
import numpy as np
import matplotlib.pyplot as plt
from numpy import ndarray


def nose_shape(x:float, L:float, Rb:float, d:float)-> float:

    """

    Parameters:
    x (float): x-position along body
    L (float): length of power-law body
    Rb (float): base radius of power-law body
    d (float): exponent in power-law body
    Returns:
    (float): y-position on body corresponding to x
    
    """
    y = Rb*(x/L)**d

    return y

def plot_nose_shape(L:float, Rb:float, d:float, number_samples:int) -> None: 

    """

    Parameters:
    L (float): length of power-law body
    Rb (float): base radius of power-law body
    d (float): exponent in power-law body
    number_samples (int): number of sample points for constructing plot
    Returns:
    None
    Side-effect:
    Plots power-law body as x-y plot to screen

    """

    #Construct an x_array to represent each x-value that is to be plotted.
    x_array = np.linspace(0,L,number_samples)

    #The subsequent y-position on body correspending to each x value in the above array is calculated. 
    y_array = ((x_array/L)**d)*Rb

    #Render the graph. 
    fig,ax = plt.subplots()

    #Set x_array and y_array as the variables to plot in the along the x and y axis respectively. Also specify the colour of the graph and the marker. 
    ax.plot(x_array, y_array,color = "blue", marker = "o")


    #Set a figure title and axis label for the graph. A figure title is constructed through the use of string concatenation. 
    fig.suptitle("Power-Law body:" + "L=" + str(L) + ", " + "Rb=" + str(Rb)+ ", " + "d=" + str(d))
    ax.set(xlabel = "x", ylabel = "y")


    ax.grid()

    plt.show()


def drag_coeff_panel(x0:float,y0:float,x1:float,y1:float)-> float:

    """

    Compute local c_d on a panel with end points (x0, y0) and (x1, y1)

    Parameters:
    x0 (float): x-position at left end of panel
    y0 (float): y-position at left end of panel
    x1 (float): x-position at right end of panel
    y1 (float): y-position at right end of panel
    Returns:
    (float): local drag coefficient
    
    """
    
    #Calculate the change in x and y value. Delta_x and delta_y are needed to calculate the angle, theta.
    delta_x = x1 - x0
    delta_y = y1 - y0

    angle = np.arctan(delta_y/delta_x)
    
    sin_angle = np.sin(angle)
    
    c_d_panel = 2*(sin_angle)**3

    return c_d_panel

    
#To calculate the total drag_coefficient, which will be assigned the variable C_D:


def drag_coeff(L: float, Rb: float, d: float, number_panels:int) -> float:

    """

    Compute drag coefficient for a power-law body.

    Parameters:
    L (float): length of power-law body
    Rb (float): base radius of power-law body
    d (float): exponent in power-law body
    number_panels (int): number of panels for use in C_D calculation
    Returns:
    (float): drag coefficient
    
    """

    #np.linspace is used to indicate the start and end point of each panel along the x-axis. 
    x_array = np.linspace(0, L, number_panels+1, True)

    y_array = ((x_array/L)**d)*Rb


    #Cdp, dx, dy, and ym lists have been initialized as they will be appended to in a while loop. 
    cdp_list = []
    dx = []
    dy = [] 
    ym = []
    
    index = 0
    while index < number_panels: 
        y0 = y_array[index]
        y1 = y_array[index+1]

        x0 = x_array[index]
        x1 = x_array[index+1]

        #Append values from x0,x1 and y0,y1 into their respective lists. 
        dx.append(x1-x0)
        dy.append(y1-y0)
        ym.append((y1-y0)/2 + y0)
        
        #Compute cdp_value using the drag_coeff_panel, and enter arguments x0,x1,y0, and y1. 
        cdp_value = drag_coeff_panel(x0, y0, x1, y1)
        cdp_list.append(cdp_value)

        index += 1

    #Convert lists into arrays so that vectorized calculations can be applied.    
    cdp_array = np.array(cdp_list) 
    dx = np.array(dx)
    dy = np.array(dy)
    ym = np.array(ym)


    #Generate the Dl array for each panel. 
    Dl_squared = (dx**2) + (dy**2)
    Dl = np.sqrt(Dl_squared)

    #An array of dA, representing the dA values at each panel,
    #can be generated by applying vectorized calculations to the dL array. 
    da_array = Dl* 2.0*(np.pi)*ym


    #Generate an array which shows the product of the da_array and cd_array:
    product_array = da_array*cdp_array


    #Calculate the sum of the elements in this product array using np.sum:
    sum_product_array = np.sum(product_array,axis= 0) 


    #Calculate the total area of the nose shape apply the np.sum operation on the dA array:
    area = np.sum(da_array, axis= 0)
    
    total_cd = round(((1/area)* sum_product_array),17)
    
    return total_cd



def print_table(L, Rb, number_panels, d_start, number_entries, step):
    
    """

    Print table of C_Ds for various choices of exponent d.

    Parameters:
    L (float): length of power-law body
    Rb (float): base radius of power-law body
    number_panels (int): number of panels in C_D calculation
    d_start (float): first exponent
    number_entries (int): number of entries displayed in table
    step (float): difference between each exponent d
    Returns:
    None
    Side-effect:
    Table is printed to screen

    """

   #Construct header sections of the table using f-strings. 
    print(29*"*")
    print (f'*{"d":^12}*{"C_D":^14}*')
    print(29*"*")

    #Initialize d_value as d_start and set increments_done as 0.
    #Initalization must be done to use these values in the loop later on.
    
    d_value = d_start
    increments_done = 0
    while increments_done < number_entries:

        drag_coeff_value = round(drag_coeff(L,Rb,d_value, number_panels),4)
        d_value = round(d_value,2) 
        print (f'*{d_value:^12}*{drag_coeff_value:^14}*')
        increments_done += 1
        d_value += step
        
    print(29*"*")

 
class PowerLawBody(object):

    #Set a constructor function in the class, which accepts arguments, L (length of nose cone),
    #Rb, d(exponent), and number_panels (total number of panels for the nose cone). 
    def __init__(self, L: float, Rb: float, d: float, number_panels: int) -> None:
        
        """
        Parameters:
        L (float): length of power-law body
        Rb (float): base radius of power-law body
        d (float): exponent in power-law body
        number_panels (int): number of panels for use in C_D calculation
        Returns:
        None

        """
        
        #Extract all the parameters from the class function. 
        self._L = L
        self._Rb = Rb
        self._d = d
        self._number_panels = number_panels

    def shape(self, x: float) -> float:

        """
        Parameters:
        x (float): x-position along body
        Returns:
        (float): y-position on body corresponding to x

        """
        y = self._Rb*(x/self._L)**self._d

        return y

    def drag_coeff_panel(self, x0:float,y0:float,x1:float,y1:float)-> float:
       
        """

        Computes C_D_panel for a specified panel segment of the nose. 

        Returns:
        (float): drag coefficient panel. 

        
        """
        
        delta_x = x1-x0
        
        delta_y = y1-y0
        
        angle = np.arctan(delta_y/delta_x)
        
        sin_angle = np.sin(angle)
        
        c_d_panel = 2*(sin_angle)**3

        return c_d_panel


    def drag_coeff(self) -> float:
    
        """

        Computes C_D for the body

        Returns:
        (float): drag coefficient

        
        """
        x_array = np.linspace(0, self._L, self._number_panels+1, True)
        y_array = ((x_array/self._L)**self._d)*self._Rb

        cdp_list = []
        dx = []
        dy = []
        ym =[]
        
        index=0
        while index < self._number_panels: 
            y0 = y_array[index]
            y1 = y_array[index+1]

            x0 = x_array[index]
            x1 = x_array[index+1]

            dx.append(x1-x0)
            dy.append(y1-y0)
            ym.append((y1-y0)/2 + y0)

            cdp_value = drag_coeff_panel(x0, y0, x1, y1)
            cdp_list.append(cdp_value)

            index += 1
            
        
        cdp_array = np.array(cdp_list)
        dx = np.array(dx)
        dy = np.array(dy)
        ym = np.array(ym)

        Dl_squared= (dx**2) + (dy**2)
        Dl = np.sqrt(Dl_squared)

        da_array = Dl* 2.0*(np.pi)*ym

        product_array = da_array*cdp_array

        sum_product_array = np.sum(product_array,axis= 0) 


        area = np.sum(da_array, axis= 0)
        
        total_cd = round(((1/area)* sum_product_array),17)

        return total_cd

    
    def set_design_param(self, d_value):

        """

        Setter method to get a user input, d_value, and reassign self._d to this parameter. 


        Returns : 
        (float) : self._d
        """
        self._d = d_value

        return self._d

    
    def __call__ (self, d):

        """
        Parameters: 
            d (float): exponent in power-law body
        Returns:
            (float): drag coefficient for value d
        
        """
        self.set_design_param(d)

        return self.drag_coeff()

    
    

def plot_drag_coeff(nose_cap: PowerLawBody, d_start: float, d_stop: float, number_samples: int):

    """
    Parameters: 
        nose_cap (PowerLawBody): the power-law body of interest
        d_start (float): the start-point power-law exponent for plotting
        d_stop (float): the stop-point power-law exponent for plotting
        number_samples (int): the total number of sample points for use in plotting

        Returns: 
            None
        Side-effect:
            Plot to screen C_D as a function of d
    """

    #Calculate the value to increment the exponent,d ,  from d_start to d_stop.
    d_increment = (d_stop-d_start)/ (number_samples -1)
    
    d_value = d_start

    #Render the graph:
    fig, ax = plt.subplots()


    #Make empty lists to append the d exponent and drag coefficinet values to. 
    d_value_list =[]
    drag_coeff_list = []

    
    samples_done = 0 
    while samples_done < number_samples:
        d_value_list.append(d_value)
        
        nose_cap.set_design_param(d_value)

        drag_coeff_list. append(nose_cap.drag_coeff())

        d_value += d_increment
        
        samples_done += 1


    #Plot the data, whilst also setting color to blue, and the marker to "o". 
    ax.plot (d_value_list, drag_coeff_list, color = "blue", marker= "o")

    #Set graph title and axis labels. 
    fig.suptitle("Drag coefficients for power_law bodies")
    ax.set(xlabel = "exponent, d", ylabel = "drag coefficient, C_D")
    

    plt.show() 
        
        
def golden_section_search(f, a, b, tol):
    
    """

    Use Golden Section Search to find a minimum of f.

    Parameters:
    f : function in one variable, accepts float, returns float
    a (float) : left end for search interval
    b (float) : right end for search interval
    tol (float): tolerance for stopping search

    Returns:
    (float): minimum of function f


    """

    g = 0.618034

    dL = a + (1-g)*(b-a)
    dR = a + g*(b-a)
    
    while dR-dL >= tol:
        

        fL = f(dL)
        fR = f(dR)

        if fL < fR:
            b = dR
            dR = dL
            fR = fL
            dL = a + (1-g) * (b-a)

        else:
            a = dL
            dL = dR
            fL = fR
            dR = a + g*(b-a)


    optimum_d = (dR+ dL)/2

    return optimum_d



    

def main() -> None:
    """Entry point to interaction"""
    print("Implement your solution and run this file")




if __name__ == "__main__":
    main()
